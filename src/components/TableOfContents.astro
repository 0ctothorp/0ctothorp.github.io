---
import { type MarkdownHeading } from 'astro';

export interface Props {
    headings: MarkdownHeading[];
    class?: string;
}

const { headings, class: className } = Astro.props;

interface Heading extends MarkdownHeading { subheadings?: Array<Heading> };

const headingsArr = headings as Array<Heading>;
  
headingsArr.forEach(heading => { heading.subheadings = []; });

const toc: Heading[] = [headingsArr[0]!]

for(let i = 1; i < headingsArr.length; i++) {
  const heading = headingsArr[i]!;
  let parent = toc.at(-1)!;
  while(heading.depth - 1> parent.depth) {
    parent = parent.subheadings!.at(-1)!;
  }
  parent.subheadings!.push(heading);
}
---

<ul class={className}>
  {
    toc[0]!.subheadings!.map((heading) => {
      return (
        <>
            <li><a data-slug={heading.slug} href={`#${heading.slug}`}>{heading.text}</a></li>
            {heading.subheadings?.length! > 0 && <Astro.self headings={heading.subheadings!} />}
        </>
      );
    })
  }
</ul>

<script define:vars={{headings}}>
  const headingIds = headings.map((heading) => heading.slug);
  const links = document.querySelectorAll(`[data-slug]`);
  const linksMap = new Map(links.entries().map(([index, element]) => [element.dataset.slug, element]));

  const intersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if(!headingIds.includes(entry.target.id)) return;
      
      if(entry.isIntersecting) {
        linksMap.get(entry.target.id)?.classList.add("text-white", );
      } else {
        linksMap.get(entry.target.id)?.classList.remove("text-white");
      }
    });
  });

  headingIds.forEach((id) => {
    intersectionObserver.observe(document.getElementById(id));
  })
</script>

