---
import { type MarkdownHeading } from 'astro';
import ToCList from './ToCList.astro';

export interface Props {
    headings: MarkdownHeading[];
    class?: string;
}

const { headings, class: className } = Astro.props;

interface Heading extends MarkdownHeading { subheadings?: Array<Heading> };

const headingsArr = headings as Array<Heading>;
  
headingsArr.forEach(heading => {
  if(!heading.subheadings) heading.subheadings = []; 
});

const toc: Heading[] = [headingsArr[0]!];

for(let i = 1; i < headingsArr.length; i++) {
  const heading = headingsArr[i]!;
  let parent = toc.at(-1)!;
  while(heading.depth - 1> parent.depth) {
    parent = parent.subheadings!.at(-1)!;
  }
  parent.subheadings!.push(heading);
}

---

<ToCList headings={toc} class={className}  />

<script define:vars={{headings}}>
  const headingIds = headings.map((heading) => heading.slug);
  const links = document.querySelectorAll(`[data-slug]`);
  const linksMap = new Map(links.entries().map(([index, element]) => [element.dataset.slug, element]));

  const intersectionObserver = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if(!headingIds.includes(entry.target.id)) return;
      
      if(entry.isIntersecting) {
        linksMap.get(entry.target.id)?.classList.add("text-white", );
      } else {
        linksMap.get(entry.target.id)?.classList.remove("text-white");
      }
    });
  });

  headingIds.forEach((id) => {
    intersectionObserver.observe(document.getElementById(id));
  })
</script>

